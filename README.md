Proactive 2
===========

React with Prolog.


## Proactive-1 Bluffer's guide
If you have used Proactive-0.8 or lower, then most of the mechanics will be familiar - to define a component, create a module with a predicate render/3.
The main difference is that there are far fewer complex components available built in to Proactive-2. Instead, you can use (out of the box) the Bootstrap components
(see https://react-bootstrap.github.io/components/alerts/) and HTML elements (div, span, input, etc) directly.
You can, of course, compose more complex components out of these by defining proactive components and using those in other proactive components.

Behind the scenes, a lot has changed. Instead of trying to replicate the virtual DOM in Prolog, a process which was often error-prone and memory-intensive in the already
rsource-limited Proscript WAM, proactive-2 just uses the React code directly, simply providing hooks to call prolog for render/3 getInitialState/2 and so on.

This means we have a lot more flexibility and control (virtually any HTML page could be generated by a proactive page), but also benefit from improvements made to React and
Bootstrap automatically.

## Getting Started
Proactive-2 requires SWI version 8 or higher as the backend.

You can start a server by running something like

    swipl -f src/server_standalone.pl -t prolog -g "main"

server_standalone.pl provides a number of hooks and stubs to get a basic version running. It comes with a very simple form provided by src/foo.pl and src/bar.pl

## Designing a component

Each proactive component corresponds to a single module. The only requirement is that the module must define a predicate render/3.

If you are familiar with React, then you know that the core process for building a component is defining the pure render() function. In proactive, the render() function always
calls render/3 in the component's module. The 3 arguments of render/3 are:
   * +State: A term representing the component's current state
   * +Props: A term representing the component's props
   * -Form: A term which render/3 must bind to a representation of the component with state State and props Props.

render/3 can (and probably should) make use of JSX. See below.

In addition to rendering, your module may provide a predicste getInitialState/2. This will be called when the component is first instantiated, and allows you to set an initial
State term given the Props passed in. The args are:
   * +Props: The component's props
   * -State: A term representing the state.

State (and props) are represented as a kind of pseudo-dict: A curly brace term with a number of name-value pairs. For example:
   * {foo: bar, baz: 6}: A state where foo is the atom 'bar' and baz is the integer 6
   * {}: An empty state

Finally, you need to be able to mutate the state to reflect changes. This happens by way of event handlers which you can attach to the underlying objects. An event handler is
one of two things. Either:
   * a term which will be called with 4 extra args (Event, State, Props, NewState), or
   * a special term which can be pass events to other components.

The second case is required so that child components can fire events in the parent and update its state. In React, this is typically achieved by the parent passing a function
to the children via the props; when the child handles an event, it can call the function, signalling that the parent to update its own state, as needed. Because there is no
way to reference the parent component in Prolog at *all*, the special 'this' term is needed. You can obtain the this pointer using get_this/1, but the most common way to use it
is in passing a prop to the child as some_prop={this.some_term_here} in JSX. If the child attaches Props.some_prop to an event trigger, then some_term_here will be called in
the *parent* context, not the child - equivalent to passing `function(){some_term_here()}.bind(this)` to a child and having the child call it.

If that is too confusing then don't worry - it's generally safe to just always refer to handlers with the this pointer when you first mention them.

There is one other case to consider - what if the child component wants to run some code and *then* (optionally) call the parent? To implement this, we need to switch the
context, which is not possible in pure Prolog, but is made possible by calling the bubble_event/2 foreign predicate. This takes 2 arguments - the handler to execute, and the
event to pass it. For example, if you have a Parent with a Child like this:
```
:-module('Parent', []).
render(_, _, Form):-
  {|jsx(Form)||<Child onEvent={this.event_handler}/>|}.

event_handler(Event, State, Props, NewState):-
  % ...


:-module('Child', []).
render(_, _, Form):-
  {|jsx(Form)||<Button onClick={this.handle_click}/>|}.

handle_click(Event, State, Props, NewState):-
   % Some conditional logic here to decide if the click is acceptable ....
   % If so, call the function provided in the onEvent prop
   bubble_event(Props.onEvent, Event).

```

## JSX
The value bound by render/3 is just an element/3 term. The args are:
   * TagName: The name of the tag,
   * Attributes: A list of =/2 pairs, corresponding to name/value pairs
   * Children: A list of terms, each of which is an atom or another element/3

This can be quite cumbersome to write code for, though. SWI supports quasiquotations, and if you include src/jsx.pl then you can write the rendering output in JSX, an XML-like
metanotation.

## Getting data from the server
There are 2 ways to get data from the server - synchronously and asynchronously.

### Synchronous data
Data can be retrieved by calling on_server(:Goal). Note that this is only possible from an event handler - it is explicitly forbidden to call it from render/3 or getInitialState/2 and attempts to do so will result in an exception being raised.

### Asynchronous data
There is a special-purpose component called MessageListener. There are 3 important props to pass in:
   * onMessage: An event handler to call when a message is received
   * class: The class of message being listened for, and
   * discriminator: A predicate which will be run to determine if a message of the given class should be sent to the client

The discriminator is there for reasons of efficiency. Suppose the application being developed is a chat server with private rooms. The event class might be 'message', but if
all messages are sent to all private rooms and discarded if inappropriate, a lot of bandwidth and processing is wasted. The discriminator is called with one extra arg - the
event itself - and if it succeeds, then the message will be delivered to your listener.

You can send a message to appropriate clients from the server by calling broadcast_proactive_message(+Class, +Event).

There are also system messages sent from the server to appropriate clients, including:
   * keep-alive pings
   * notifications that the source has changed and may need to be reloaded.

You can trigger the second one with a call to trigger_proactive_recompile(+Module), typically implemented as an end-of-file hook (see the example in src/server_standalone.pl


## Embedding Proactive in your application
There are several things required to bind Proactive into an application:
   * You must consult src/proactive.pl.
      * You may consult src/jsx.pl if your forms use JSX.
   * You must start a web server
   * You need to provide access to the files in lib. These can be distributed however you like - the file search path proactive_lib is used to find them at runtime
   * You must implement proactive:goal_is_safe/1 if you want on_server/1 to accept any goals
   * You may implement a clause of proactive:proactive_goal_hook(+Request, :Goal) if you want to handle on_server/1 goals yourself
   * You may implement proactive:allow_access_to_form(+Form) if you want to restrict access to any forms
   * You may implement proactive:open_proactive_session_hook(+SessionID) and proactive:close_proactive_session_hook(+SessionID) if you want to trigger any events when
     proactive sessions are created
